# TypeScript Patterns in This Project

## What It Is

This document catalogs the specific TypeScript patterns, conventions, and idioms used throughout HankoSign Digital. Rather than teaching TypeScript generally, it shows how TypeScript is applied here.

## Pattern 1: Prisma-Generated Types as Single Source of Truth

Prisma generates TypeScript types from `schema.prisma`. These types are the authoritative definition of all data shapes.

```typescript
// Generated by Prisma (in node_modules/@prisma/client)
// These types match the database schema exactly

// Import generated types
import { PrismaClient, Role, HankoType, DocumentStatus, ApprovalStatus } from '@prisma/client';

// Type-safe queries - Prisma enforces correct field names and types
const user = await prisma.user.create({
  data: {
    email: 'user@example.com',     // must be string
    name: '田中太郎',               // must be string
    password: hashedPassword,       // must be string
    role: Role.USER,                // must be a Role enum value
    // companyName is optional (String? in schema)
  },
});
// user is typed as User (with all fields)

// Type-safe includes
const documents = await prisma.document.findMany({
  include: {
    signatures: {
      include: {
        user: { select: { name: true, email: true } },
        hanko: true,
      },
    },
  },
});
// documents[0].signatures[0].user.name is typed as string
// documents[0].signatures[0].hanko is typed as Hanko
```

**Key insight:** Never manually define interfaces for database models. Always import from `@prisma/client`.

## Pattern 2: Zod Schemas for Runtime Validation

TypeScript types are erased at runtime. Zod provides runtime validation that mirrors TypeScript's type system.

```typescript
// API route pattern: Zod schema validates incoming data
const registerSchema = z.object({
  email: z.string().email('Please enter a valid email address').max(255),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .max(128)
    .regex(/[A-Z]/, 'Password must include uppercase letters')
    .regex(/[a-z]/, 'Password must include lowercase letters')
    .regex(/[0-9]/, 'Password must include numbers'),
  name: z.string().min(1, 'Please enter your name').max(100),
  nameKana: z.string().max(100).optional(),
  companyName: z.string().max(200).optional(),
});

// In the route handler:
const body = await request.json();              // body is 'any' (unknown JSON)
const validatedData = registerSchema.parse(body); // now fully typed and validated
// validatedData.email is string (guaranteed by Zod)
// validatedData.nameKana is string | undefined (optional in schema)
```

**Pattern:** Every `POST` API route defines a Zod schema at the top of the file, then calls `.parse()` on the request body inside the handler.

## Pattern 3: NextAuth Session Extension

NextAuth.js has default session types that don't include custom fields like `id` and `role`. The project extends them through callbacks and type assertions.

```typescript
// lib/auth.ts - JWT callback adds custom fields to token
callbacks: {
  async jwt({ token, user }) {
    if (user) {
      token.id = user.id;       // add user ID to JWT
      token.role = user.role;   // add role to JWT
    }
    return token;
  },
  async session({ session, token }) {
    if (session.user) {
      session.user.id = token.id as string;     // type assertion needed
      session.user.role = token.role as string;  // NextAuth types don't include these
    }
    return session;
  },
},

// Usage in API routes
const session = await getServerSession(authOptions);
const userId = session.user.id;   // available because of callback above

// Usage in permission helpers (lib/permissions.ts)
const userRole = (session.user as any).role as UserRole;
// 'as any' is needed because NextAuth's Session type doesn't include 'role'
```

## Pattern 4: Singleton with globalThis

Prevent multiple instances during Next.js hot module reloading:

```typescript
// lib/prisma.ts
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

**Type pattern:** `globalThis as unknown as { prisma: ... }` is a double assertion. First to `unknown` (safe), then to the desired shape. This is needed because `globalThis` doesn't normally have a `prisma` property.

## Pattern 5: Discriminated Union for Component Variants

The Alert component uses a discriminated union pattern:

```typescript
// components/Alert.tsx
type AlertVariant = 'error' | 'success' | 'warning' | 'info';

interface AlertProps {
  variant: AlertVariant;
  children: ReactNode;
  className?: string;
}

const variantStyles: Record<AlertVariant, { container: string; icon: ReactNode }> = {
  error: {
    container: 'border-red-200 bg-red-50 text-red-700',
    icon: <XCircle className="h-5 w-5 flex-shrink-0" />,
  },
  success: {
    container: 'border-green-200 bg-green-50 text-green-700',
    icon: <CheckCircle2 className="h-5 w-5 flex-shrink-0" />,
  },
  // ...
};

export default function Alert({ variant, children, className = '' }: AlertProps) {
  const styles = variantStyles[variant];  // TypeScript guarantees variant is a valid key
  return (
    <div className={`... ${styles.container} ${className}`}>
      {styles.icon}
      <div>{children}</div>
    </div>
  );
}
```

**Pattern:** `Record<UnionType, ValueType>` ensures every variant has a corresponding style. If you add a new variant to `AlertVariant`, TypeScript will error until you add it to `variantStyles`.

## Pattern 6: `as const` for Immutable Configurations

```typescript
// components/HankoDesigner.tsx
const FONT_OPTIONS = [
  { value: 'serif', key: 'fontSerif' },
  { value: 'sans-serif', key: 'fontSansSerif' },
  { value: 'cursive', key: 'fontCursive' },
  { value: 'monospace', key: 'fontMonospace' },
] as const;

// Without 'as const': type is { value: string; key: string }[]
// With 'as const': type is readonly [
//   { readonly value: 'serif'; readonly key: 'fontSerif' },
//   ...
// ]
```

This preserves literal types, prevents accidental mutations, and enables better type narrowing.

## Pattern 7: Conditional Object Properties with Spread

```typescript
// lib/s3.ts - conditionally include endpoint config
const s3Client = new S3Client({
  region: REGION,
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',
  },
  ...(S3_ENDPOINT ? {
    endpoint: S3_ENDPOINT,
    forcePathStyle: true,   // needed for MinIO
  } : {}),
});
```

**Pattern:** `...(condition ? { props } : {})` adds properties only when a condition is met. The empty object `{}` spreads nothing.

## Pattern 8: Component Props with ReactNode

```typescript
// components/Alert.tsx
import { ReactNode } from 'react';

interface AlertProps {
  variant: AlertVariant;
  children: ReactNode;     // accepts any valid React child
  className?: string;      // optional string
}

// components/AuthProvider.tsx
export default function AuthProvider({
  children,
}: {
  children: React.ReactNode;  // inline type definition
}) {
  return <SessionProvider>{children}</SessionProvider>;
}
```

`ReactNode` is the type for anything that can be rendered: strings, numbers, JSX elements, arrays, fragments, null.

## Pattern 9: Next.js API Route Types

```typescript
import { NextRequest, NextResponse } from 'next/server';

// Route handlers use specific function names matching HTTP methods
export async function GET(request: NextRequest) {
  return NextResponse.json({ data: ... });
}

export async function POST(request: NextRequest) {
  return NextResponse.json({ data: ... }, { status: 201 });
}

export async function DELETE(request: NextRequest) {
  // Extract query params with URL parsing
  const { searchParams } = new URL(request.url);
  const id = searchParams.get('id');   // returns string | null
  return NextResponse.json({ message: 'Deleted' });
}
```

## Pattern 10: Async Layout with Promise Params

Next.js 16 passes route params as a `Promise`:

```typescript
// app/[locale]/layout.tsx
export default async function LocaleLayout({
  children,
  params,
}: {
  children: React.ReactNode;
  params: Promise<{ locale: string }>;  // Promise in Next.js 16+
}) {
  const { locale } = await params;      // must await

  if (!routing.locales.includes(locale as any)) {
    notFound();
  }

  const messages = await getMessages();

  return (
    <div className={notoSansJP.className}>
      <NextIntlClientProvider messages={messages}>
        <AuthProvider>{children}</AuthProvider>
      </NextIntlClientProvider>
    </div>
  );
}
```

## Type Safety Gaps

Areas where the project relies on `any` or loose typing:

| Location | Issue | Reason |
|----------|-------|--------|
| `lib/permissions.ts:100` | `(session.user as any).role` | NextAuth types don't include custom `role` field |
| `lib/redis.ts:19` | `value: any` parameter | Redis stores serialized JSON of any shape |
| `components/HankoDesigner.tsx:24` | `useState<any>(null)` | Fabric.js Canvas type is complex and dynamic |
| `components/HankoDesigner.tsx:23` | `useRef<any>(null)` | Fabric.js module type varies by import method |

These are pragmatic choices. Fixing them would require NextAuth module augmentation (for the session) and complex Fabric.js type imports (for the canvas).

## Key Files

- `lib/auth.ts` - Session type extension via callbacks
- `lib/prisma.ts` - globalThis double assertion singleton
- `lib/permissions.ts` - Union types, interfaces, function overloads
- `lib/redis.ts` - Generic cache functions
- `lib/s3.ts` - Conditional spread pattern
- `components/Alert.tsx` - Record type, discriminated union
- `components/HankoDesigner.tsx` - as const, refs, dynamic import types
- `app/api/*/route.ts` - Zod + NextRequest/NextResponse types
- `prisma/schema.prisma` - Source of all generated types

## Resources

- [TypeScript Handbook: Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
- [Prisma: TypeScript](https://www.prisma.io/docs/orm/prisma-client/type-safety)
- [NextAuth.js: TypeScript](https://next-auth.js.org/getting-started/typescript)
- [Zod: TypeScript-first Validation](https://zod.dev/)
